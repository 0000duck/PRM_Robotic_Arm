# PRM

* 点是6维度的点，是6维度矩阵，代表每个轴的角度

* 障碍及机械臂的状态碰撞检测是3维的，XYZ

* 扫面是三维的



# 行动路线图
* ~~机械臂建模~~
* ~~求得机械臂运动学解公式~~
* 空间点到点算法模拟
    - ~~已知起点6维状态，求得当前tool末端空间位置及生成全机械臂离散点坐标~~
    - 根据离散坐标生成空间实体  （PS方案）
    - ~~已知终点tool末端位置，反解6维状态位置~~
    - ~~随机生成6维点，查找扫面~~
>         + 不验证冲撞，不验证障碍，（ROS模拟器）
>         + ~~验证自身冲撞，验证扫面冲撞，不验证障碍 （实测）~~
>         + 验证自身冲撞，验证扫面冲撞，验证虚拟障碍 （ROS虚拟放置，实测）
>         + 障碍使用传感器或随机速度履带测得
    - 查询，运行到位
        
## MATLAB流程图
* ~~正向解~~
* ~~反解末端位置~~
    - ~~符合PIEPER准则~~
    - ~~获得D-H参数~~
    - ~~已知目标点坐标，令方位为单位阵，生成目标姿态 Tt-b~~
    - ~~由T0-b * T6-0 * Tt-6 = Tt-b反解出T6-0表达~~
    - ~~获得第6点的坐标和旋转阵~~
    - ~~。。。~~
* 生成随机6维点
* 6维点正向解
* 查询
    - 查询规则
    - 6维查询步进
    - 自身碰撞检测
        + 步进生成自身占用空格
        + 步进自身位置点与占格对比

# 模型

## anno机械臂参数表

> Pb = [1,0,0,0;  0,1,0,0;    0,0,1,0;    0,0,0,1];
> 

> Ts_b = [cos(theta1),-sin(theta1),0,0;  sin(theta1),cos(theta1),0,0;    0,0,1,0;  0,0,0,1];
> Ta_s = [1,0,0,0;    0,cos(theta2),-sin(theta2),0;    0,sin(theta2),cos(theta2),264;  0,0,0,1];
> Te_a = [1,0,0,0;    0,cos(theta3),-sin(theta3),225;  0,sin(theta3),cos(theta3),0;    0,0,0,1];
> Tw_e = [cos(theta4),-sin(theta4),0,0;   sin(theta4),cos(theta4),0,0;    0,0,1,-80;   0,0,0,1];
> Tf_w = [1,0,0,0;    0,cos(theta5),-sin(theta5),0;    0,sin(theta5),cos(theta5),-137;  0,0,0,1];
> Tt_f = [cos(theta6),-sin(theta6),0,0;   sin(theta6),cos(theta6),0,0;    0,0,1,-40;   0,0,0,1];
> Ttail= [1,0,0,0;    0,1,0,0;    0,0,1,0;    0,0,0,1];

## 数学模型和控制模型
* 控制原点等价于数学零点，0x7fffffff　= 0度
* 直立点不再考虑
* 初始化点为零点


## 离散碰撞检测
* 确定离散步进（确保距离限制和控制时间是合理的，能够完成的）
* ~~输入起点和终点6维坐标~~
* ~~6维坐标步进~~
* ~~各步进产生关键点坐标~~
* ~~各步进相邻关键点坐标建立点到点离散点集~~
    - ~~各关节长度已知，可以事先配置好离散精度~~
* ~~设置障碍时把障碍离散成为点集~~
* ~~障碍检测被离散为点到点3维空间距离的检测（没必要开根号）~~

## FPGA友好型改进
### 碰撞检测
* 全空间10bit * 10bit * 10bit离散为grid 30.
    - XY 回转半径算500，则各1024mm，离散精度1mm
    - Z 也当1000算
* 申请n个48bit Ob_reg寄存器代表实时障碍，n为障碍点离散个数，每个寄存器表示实际存在额障碍标号，
* 流式传输48bit机械臂实体点进行检测
* 标记机械臂关键点坐标号，展开实体占用格，实体体积一定，占用格数量一定，不存在步进格数和距离问题。
* 机械臂体积越大，占用格数越多，需要打的拍越多。（不算并行）
* 
* 函数修改两个寄存器
* 碰撞检测 ，按位与，出现1则碰撞。


### 几何转占格
* XYZ坐标直接变占格
* shoulder
    - 直径160，高264，占用6758400个格子
    - 可以忽略
* arm
    - 直径140 ，高225，占用4410000个格子
* elbow&wrist 
    - 直径100 ，高217，占用 2170000个格子
* finger&tool
    - 直径60 ，高40+，占用  144000个格子

### 使用圆环栅格
* 6bit 角度0~180 4bit半径 80-512 5bit z 0-1024
* 中间密，周围疏
* 省略shoulder的浪费格
* 旋转友好。。。

###PRM按粒度进行拆解
1. 获得障碍物的占用栅格数组
2. 流式处理，输出可用路径的mask
3. mask与运算
4. 根据可用路径进行图类查找

### 实现1
1. 获得障碍物的占用栅格数组
2. 复位逻辑
3. 流式处理，输出可用路径的mask
4. mask与运算
5. 结束，导出mask
6. 已知起点终点的6维坐标（初始化）
7. 初始化Pose 到起点终点距离
8. 初始化Edge，（有吗）
7. 起点终点全点碰撞检测生成附加路径（初始化）
8. 图算法
    * 计算起点到各点的距离代价g（n）
~~  * 计算各点到终点的距离代价h（n）~~
    * 选中起点
    * while（1）
        - for 所有未选中的点
        - 选中所有选中集合可达的点
        - if 包括终点 break
9. 建立路径图




